# OAuth 2.0 인가 프레임워크

[RFC 6849](https://datatracker.ietf.org/doc/html/rfc6749#section-1)

개념
- OAuth 2.0 인가 프레임워크는 타사 어플리케이션이 자원 소유자와 HTTP 서비스 간의 승인 상호작용을 조정하여 리소스 소유자를 대신하여 HTTP 서비스에 대한 제한된 액세스를 얻거나 타사 어플리케이션이 스스로 액세스를 얻도록 허용하여 HTTP 서비스에 대한 제한된 액세스를 얻도록 한다. 
  이 사양은 RFC 5849에 설명된 [OAuth1.0](https://datatracker.ietf.org/doc/html/rfc5849) 프로토콜을 대체한다. 
 

## 1. 소개

기존 클라이언트-서버 인증 모델에서 클라이언트는 자원 소유자의 자격 증명을 사용하여 서버와 인증하여 접근이 제한된 자원(보호된)을 요청한다. 
타사 애플리케이션에 제한된 자원에 대한 접근을 제공하기 위해 자원 소유자는 자격 증명을 타사와 공유합니다. 이로 인해 여러 가지 문제와 제한이 발생한다.

- 타사 애플리케이션은 향후 사용을 위해 자원 소유자의 자격 증명을 저장해야 하며, 일반적으로 일반 텍스트로 된 비밀번호이다.
- 서버는 비밀번호에 내재된 보안 취약점에도 불구하고 비밀번호 인증을 지원해야 한다.
- 타사 애플리케이션은 자원 소유자의 보호된 자원에 꽤나 광범위하게 접근하며, 자원 소유자가 **제한된 자원 하위 집합에 대한 기간이나 접근**을 제한할 수 있는 능력이 없게 된다.
- 자원 소유자는 모든 제 3자에 대한 접근 취소하지 않고는 개별 제 3자에 대한 접근를 취소할 수 없으며 제3자의 비밀번호를 변경하는 방법 밖에 없다.
- 타사 애플리케이션이 손상되면 최종 사용자의 비밀번호와 해당 비밀번호로 보호되는 모든 데이터가 손상된다.

OAuth는 권한 부여 계층을 도입하고 클라이언트의 역할을 자원 소유자의 역할과 분리하여 이러한 문제를 해결한다. 
OAuth에서 클라이언트는 자원 소유자가 제어하고 `자원 서버(Resource Server)`에서 호스팅하는 리소스에 대한 접근 요청하고 자원 소유자의 자격 증명과 다른 자격 증명 집합을 발급받는다.

자원 소유자의 자격 증명을 사용하여 보호된 자원에 접근하는 방법 대신 클라이언트는 액세스 토큰을 얻는다. 액세스 토큰은 특정 범위, 수명 및 기타 접근 속성을 나타내는 문자열이다. 
액세스 토큰은 자원 소유자의 승인을 받아 `인가 서버(Authorization Server)`에서 타사 클라이언트에게 발급합니다. 클라이언트는 액세스 토큰을 사용하여 리소스 서버에서 호스팅하는 보호된 자원에 접근한다.

예를 들어, 최종 사용자(자원 소유자)는 인쇄 서비스(클라이언트)에 사진 공유 서비스(자원 서버)에 저장된 보호된 사진에 대한 접근 권한을 부여할 수 있으며, 인쇄 서비스와는 사용자 이름 및 비밀번호를 공유하지 않아도 된다. 
대신, 자원 소유자는 사진 공유 서비스에서 신뢰하는 서버(인가 서버)에 직접 인증하고, 이 서버는 인쇄 서비스 위임 전용 자격 증명(액세스 토큰)을 발급한다.

이 사양은 HTTP([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616))와 함께 사용하도록 설계되었으며, HTTP가 아닌 다른 프로토콜을 통한 OAuth 사용은 범위를 벗어난다.

OAuth 1.0 프로토콜([OAuth1.0](https://datatracker.ietf.org/doc/html/rfc5849))은 정보 제공용 문서로 게시되었으며, 소규모 임시 커뮤니티 활동의 결과 정도였다. 
이 표준 트랙 사양은 OAuth 1.0 배포 경험과 광범위한 IETF 커뮤니티에서 수집한 추가 사용 사례 및 확장성 요구 사항을 기반으로 한다. 
OAuth 2.0 프로토콜은 OAuth 1.0과 이전 버전과 호환되지 않는다. 두 버전이 네트워크에서 공존할 수 있으며 구현에서 둘 다 지원하기는 것은 선택할 수 있다. 
그러나 이 사양의 의도는 새로운 구현이 이 문서에 명시된 대로 OAuth 2.0을 지원하고 OAuth 1.0은 기존 배포를 지원하는 데만 사용된다는 것이다. 
OAuth 2.0 프로토콜은 OAuth 1.0 프로토콜과 구현 세부 정보를 거의 공유하지 않는다. OAuth 1.0에 익숙한 구현자는 구조와 세부 정보에 대한 가정 없이 이 문서에 접근해야 한다.

### 1.1 역할::roles

OAuth는 다음과 같은 4가지의 역할을 정의한다.

- 자원 소유자 (Resource Owner)
  - 보호된 리소스에 대한 접근을 허용할 수 있는 독립체. 자원 소유자가 개인인 경우, 이를 최종 사용자라고 한다.
- 자원 서버 (Resource Server)
  - 보호된 자원 호스팅하는 서버는 액세스 토큰을 사용하여 보호된 자원 요청을 수락하고 응답할 수 있다.
- 클라이언트 (Client)
  - 자원 소유자를 대신하여 보호된 자원 요청을 하고 해당 자원 소유자의 승인을 받은 애플리케이션. "클라이언트"라는 용어는 특정 구현 특성(예: 애플리케이션이 서버, 데스크톱 또는 기타 장치에서 실행되는지 여부)을 의미하지 않는다.
- 인가 서버 (Authorization Server)
  - 자원 소유자를 성공적으로 인증하고 권한을 얻은 후 클라이언트에 액세스 토큰을 발급하는 서버.

인가 서버와 자원 서버 간의 상호 작용은 이 사양의 범위를 벗어난다. 인가 서버는 자원 서버와 동일한 서버이거나 별도의 독립체 일 수 있다.
단일 인가 서버는 여러 자원 서버에서 허용하는 액세스 토큰을 발급할 수 있습니다.


### 1.2 프로토콜 흐름::protocol-flow

```
        +--------+                               +---------------+
        |        |--(A)- Authorization Request ->|   Resource    |
        |        |                               |     Owner     |
        |        |<-(B)-- Authorization Grant ---|               |
        |        |                               +---------------+
        |        |
        |        |                               +---------------+
        |        |--(C)-- Authorization Grant -->| Authorization |
        | Client |                               |     Server    |
        |        |<-(D)----- Access Token -------|               |
        |        |                               +---------------+
        |        |
        |        |                               +---------------+
        |        |--(E)----- Access Token ------>|    Resource   |
        |        |                               |     Server    |
        |        |<-(F)--- Protected Resource ---|               |
        +--------+                               +---------------+
```

위에 나와 있는 추상적인 OAuth 2.0 흐름은 4가지 역할 간의 상호 작용을 설명하며 다음 단계를 포함한다:


* (A): 클라이언트는 자원 소유자에게 권한을 요청한다. 이는 두가지 방법이 있는데 아래와 같다.
    * 직접 요청: 권한 요청은 자원 소유자에게 직접(표시된 대로) 직접 요청한다. (이 방법은 3자에게 자격증명이 노출될 수 있으므로 자주 사용되지 않는다.)
    * 간접 요청: OAuth에서 선호 되는 방식이며, 중개자로서 인가 서버로 리다이렉트를 통해 신뢰할 수있는 도메인에서 인증할 수 있다.
* (B): 클라이언트는 자원 소유자의 권한을 나타내는 자격 증명인 인가를 받는다. 
    * 이 사양에 정의된 **네 가지 권한 부여 유형** 중 하나를 사용하거나 **확장 권한 부여 유형**을 사용한다. 
    * 권한 부여 유형은 클라이언트가 권한을 요청하는 데 사용하는 방법과 권한 부여 서버에서 지원하는 유형에 따라 달라진다.
* (C): 클라이언트는 인가서버에 인증하고 권한 부여를 제시하여 액세스 토큰을 요청한다.
* (D): 인가서버는 클라이언트를 인증하고 권한 부여를 검증하며, 유효하다면 액세스 토큰을 발행한다.
* (E): 클라이언트는 자원 서버로 부터 보호된 자원을 요청하고 액세스 토큰을 제시하여 인증한다.
* (F): 자원 서버는 액세스 토큰을 검증하고 유효하다면, 요청을 처리한다.

클라이언트가 자원 소유자로 부터 권한 부여를 얻기 위한(단계 (A)및 (B)에 표시됨) 선호되는 방법은 인가서버를 중개자로 사용하는 것이며, 이는 [4.1절]()에 보여진다.

### 1.3 권한 부여::authorization grant

권한 부여는 클라이언트가 액세스 토큰을 얻는 데 사용하는 자원 소유자의 권한(보호된 자원에 접근하기 위한)을 나타내는 자격 증명이다. 
이 사양은 네 가지 권한 부여 유형(권한 부여 코드, 암묵적, 자원 소유자 비밀번호 자격 증명 및 클라이언트 자격 증명)과 추가 유형을 정의하기 위한 확장성 메커니즘을 정의한다.

### 1.3.1 권한 부여 코드::authorization-code

권한 부여 코드(`Authorization Code`)는 클라이언트와 자원 소유자 사이에서 중개자 역할을 하는 인가 서버로부터 권한이 얻어진다.
자원 소유자로 부터직접 인가를 요청하는것 대신 클라이언트는 인가 서버로 자원 소유자를 안내하고 ([RFC 2616](https://datatracker.ietf.org/doc/html/rfc2616)에 정의된 user-agent를 통해), 
인가 서버는 다시 자원 소유자를 권한 부여 코드와 함께 클라이언트로 돌려 보낸다.

인가서버는 자원 소유자를 권한부여 코드와 함께 클라이언트로 돌려 보내기 전에, 자원 소유자를 인증하고 자원 접근에 대한 승인을 얻는다.
자원 소유자는 인가 서버하고만 인증하기 때문에, 자원 소유자의 자격 증명은 클라이언트와 절대 공유되지 않는다.

권한부여 코드 방식은 클라이언트를 인증하고 클라이언트로 액세스 토큰을 직접 전송하는 몇가지 중요한 보안 이점을 제공한다.
또한 이는 자원 소유자의 user-agent를 통해 통과한다거나 액세스 토큰을 다른이에게 노출시키지 않는다.

> User-Agent는 헤더 값이지만 이는 브라우저를 의미한다. 즉 브라우저 통과 없이를 말한다.


### 1.3.2 암묵적::implicit