# OAuth 2.0 인가 프레임워크

[RFC 6849](https://datatracker.ietf.org/doc/html/rfc6749#section-1)

개념
- OAuth 2.0 인가 프레임워크는 타사 어플리케이션이 자원 소유자와 HTTP 서비스 간의 승인 상호작용을 조정하여 리소스 소유자를 대신하여 HTTP 서비스에 대한 제한된 액세스를 얻거나 타사 어플리케이션이 스스로 액세스를 얻도록 허용하여 HTTP 서비스에 대한 제한된 액세스를 얻도록 한다. 
  이 사양은 RFC 5849에 설명된 [OAuth1.0](https://datatracker.ietf.org/doc/html/rfc5849) 프로토콜을 대체한다. 
 

## 1. 소개

기존 클라이언트-서버 인증 모델에서 클라이언트는 자원 소유자의 자격 증명을 사용하여 서버와 인증하여 접근이 제한된 자원(보호된)을 요청한다. 
타사 애플리케이션에 제한된 자원에 대한 접근을 제공하기 위해 자원 소유자는 자격 증명을 타사와 공유합니다. 이로 인해 여러 가지 문제와 제한이 발생한다.

- 타사 애플리케이션은 향후 사용을 위해 자원 소유자의 자격 증명을 저장해야 하며, 일반적으로 일반 텍스트로 된 비밀번호이다.
- 서버는 비밀번호에 내재된 보안 취약점에도 불구하고 비밀번호 인증을 지원해야 한다.
- 타사 애플리케이션은 자원 소유자의 보호된 자원에 꽤나 광범위하게 접근하며, 자원 소유자가 **제한된 자원 하위 집합에 대한 기간이나 접근**을 제한할 수 있는 능력이 없게 된다.
- 자원 소유자는 모든 제 3자에 대한 접근 취소하지 않고는 개별 제 3자에 대한 접근를 취소할 수 없으며 제3자의 비밀번호를 변경하는 방법 밖에 없다.
- 타사 애플리케이션이 손상되면 최종 사용자의 비밀번호와 해당 비밀번호로 보호되는 모든 데이터가 손상된다.

OAuth는 권한 부여 계층을 도입하고 클라이언트의 역할을 자원 소유자의 역할과 분리하여 이러한 문제를 해결한다. 
OAuth에서 클라이언트는 자원 소유자가 제어하고 `자원 서버(Resource Server)`에서 호스팅하는 리소스에 대한 접근 요청하고 자원 소유자의 자격 증명과 다른 자격 증명 집합을 발급받는다.

자원 소유자의 자격 증명을 사용하여 보호된 자원에 접근하는 방법 대신 클라이언트는 액세스 토큰을 얻는다. 액세스 토큰은 특정 범위, 수명 및 기타 접근 속성을 나타내는 문자열이다. 
액세스 토큰은 자원 소유자의 승인을 받아 `인가 서버(Authorization Server)`에서 타사 클라이언트에게 발급합니다. 클라이언트는 액세스 토큰을 사용하여 리소스 서버에서 호스팅하는 보호된 자원에 접근한다.

예를 들어, 최종 사용자(자원 소유자)는 인쇄 서비스(클라이언트)에 사진 공유 서비스(자원 서버)에 저장된 보호된 사진에 대한 접근 권한을 부여할 수 있으며, 인쇄 서비스와는 사용자 이름 및 비밀번호를 공유하지 않아도 된다. 
대신, 자원 소유자는 사진 공유 서비스에서 신뢰하는 서버(인가 서버)에 직접 인증하고, 이 서버는 인쇄 서비스 위임 전용 자격 증명(액세스 토큰)을 발급한다.

이 사양은 HTTP([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616))와 함께 사용하도록 설계되었으며, HTTP가 아닌 다른 프로토콜을 통한 OAuth 사용은 범위를 벗어난다.

OAuth 1.0 프로토콜([OAuth1.0](https://datatracker.ietf.org/doc/html/rfc5849))은 정보 제공용 문서로 게시되었으며, 소규모 임시 커뮤니티 활동의 결과 정도였다. 
이 표준 트랙 사양은 OAuth 1.0 배포 경험과 광범위한 IETF 커뮤니티에서 수집한 추가 사용 사례 및 확장성 요구 사항을 기반으로 한다. 
OAuth 2.0 프로토콜은 OAuth 1.0과 이전 버전과 호환되지 않는다. 두 버전이 네트워크에서 공존할 수 있으며 구현에서 둘 다 지원하기는 것은 선택할 수 있다. 
그러나 이 사양의 의도는 새로운 구현이 이 문서에 명시된 대로 OAuth 2.0을 지원하고 OAuth 1.0은 기존 배포를 지원하는 데만 사용된다는 것이다. 
OAuth 2.0 프로토콜은 OAuth 1.0 프로토콜과 구현 세부 정보를 거의 공유하지 않는다. OAuth 1.0에 익숙한 구현자는 구조와 세부 정보에 대한 가정 없이 이 문서에 접근해야 한다.

### 1.1 역할::roles

OAuth는 다음과 같은 4가지의 역할을 정의한다.

- 자원 소유자 (Resource Owner)
  - 보호된 리소스에 대한 접근을 허용할 수 있는 독립체. 자원 소유자가 개인인 경우, 이를 최종 사용자라고 한다.
- 자원 서버 (Resource Server)
  - 보호된 자원 호스팅하는 서버는 액세스 토큰을 사용하여 보호된 자원 요청을 수락하고 응답할 수 있다.
- 클라이언트 (Client)
  - 자원 소유자를 대신하여 보호된 자원 요청을 하고 해당 자원 소유자의 승인을 받은 애플리케이션. "클라이언트"라는 용어는 특정 구현 특성(예: 애플리케이션이 서버, 데스크톱 또는 기타 장치에서 실행되는지 여부)을 의미하지 않는다.
- 인가 서버 (Authorization Server)
  - 자원 소유자를 성공적으로 인증하고 권한을 얻은 후 클라이언트에 액세스 토큰을 발급하는 서버.

인가 서버와 자원 서버 간의 상호 작용은 이 사양의 범위를 벗어난다. 인가 서버는 자원 서버와 동일한 서버이거나 별도의 독립체 일 수 있다.
단일 인가 서버는 여러 자원 서버에서 허용하는 액세스 토큰을 발급할 수 있습니다.


### 1.2 프로토콜 흐름::protocol-flow

```
        +--------+                               +---------------+
        |        |--(A)- Authorization Request ->|   Resource    |
        |        |                               |     Owner     |
        |        |<-(B)-- Authorization Grant ---|               |
        |        |                               +---------------+
        |        |
        |        |                               +---------------+
        |        |--(C)-- Authorization Grant -->| Authorization |
        | Client |                               |     Server    |
        |        |<-(D)----- Access Token -------|               |
        |        |                               +---------------+
        |        |
        |        |                               +---------------+
        |        |--(E)----- Access Token ------>|    Resource   |
        |        |                               |     Server    |
        |        |<-(F)--- Protected Resource ---|               |
        +--------+                               +---------------+
```

위에 나와 있는 추상적인 OAuth 2.0 흐름은 4가지 역할 간의 상호 작용을 설명하며 다음 단계를 포함한다:


* (A): 클라이언트는 자원 소유자에게 권한을 요청한다. 이는 두가지 방법이 있는데 아래와 같다.
    * 직접 요청: 권한 요청은 자원 소유자에게 직접(표시된 대로) 직접 요청한다. (이 방법은 3자에게 자격증명이 노출될 수 있으므로 자주 사용되지 않는다.)
    * 간접 요청: OAuth에서 선호 되는 방식이며, 중개자로서 인가 서버로 리다이렉트를 통해 신뢰할 수있는 도메인에서 인증할 수 있다.
* (B): 클라이언트는 자원 소유자의 권한을 나타내는 자격 증명인 인가를 받는다. 
    * 이 사양에 정의된 **네 가지 권한 부여 유형** 중 하나를 사용하거나 **확장 권한 부여 유형**을 사용한다. 
    * 권한 부여 유형은 클라이언트가 권한을 요청하는 데 사용하는 방법과 권한 부여 서버에서 지원하는 유형에 따라 달라진다.
* (C): 클라이언트는 인가서버에 인증하고 권한 부여를 제시하여 액세스 토큰을 요청한다.
* (D): 인가서버는 클라이언트를 인증하고 권한 부여를 검증하며, 유효하다면 액세스 토큰을 발행한다.
* (E): 클라이언트는 자원 서버로 부터 보호된 자원을 요청하고 액세스 토큰을 제시하여 인증한다.
* (F): 자원 서버는 액세스 토큰을 검증하고 유효하다면, 요청을 처리한다.

클라이언트가 자원 소유자로 부터 권한 부여를 얻기 위한(단계 (A)및 (B)에 표시됨) 선호되는 방법은 인가서버를 중개자로 사용하는 것이며, 이는 [4.1절]()에 보여진다.

### 1.3 권한 부여::authorization grant

권한 부여는 클라이언트가 액세스 토큰을 얻는 데 사용하는 자원 소유자의 권한(보호된 자원에 접근하기 위한)을 나타내는 자격 증명이다. 
이 사양은 네 가지 권한 부여 유형(권한 부여 코드, 암묵적, 자원 소유자 비밀번호 자격 증명 및 클라이언트 자격 증명)과 추가 유형을 정의하기 위한 확장성 메커니즘을 정의한다.

### 1.3.1 권한 부여 코드::authorization-code

권한 부여 코드(`Authorization Code`)는 클라이언트와 자원 소유자 사이에서 중개자 역할을 하는 인가 서버로부터 권한이 얻어진다.
자원 소유자로 부터직접 인가를 요청하는것 대신, 클라이언트는 인가 서버로 자원 소유자를 안내하고 ([RFC 2616](https://datatracker.ietf.org/doc/html/rfc2616)에 정의된 user-agent를 통해), 
인가 서버는 다시 자원 소유자를 권한 부여 코드와 함께 클라이언트로 돌려 보낸다.

이때, 인가서버는 자원 소유자를 권한부여 코드와 함께 클라이언트로 돌려 보내기 전에, 자원 소유자를 인증하고 자원 접근에 대한 승인을 얻는다.
자원 소유자는 인가 서버하고만 인증하기 때문에, 자원 소유자의 자격 증명은 클라이언트와 절대 공유되지 않는다.

권한부여 코드 방식은 클라이언트를 인증하고 클라이언트로 액세스 토큰을 직접 전송하는 몇가지 중요한 보안 이점을 제공한다.
또한 이는 자원 소유자의 user-agent를 통해 통과한다거나 액세스 토큰을 다른이에게 노출시키지 않는다.

> User-Agent는 헤더 값이지만 이는 브라우저를 의미한다. 즉 브라우저 통과 없이를 말한다.


### 1.3.2 암묵적::implicit

암묵적 허가는 JavaScript와 같은 스크립팅 언어를 사용하여 브라우저에서 구현된 클라이언트에 최적화되어 간소화된 권한 부여 코드의 흐름이다. 
암묵적 흐름에서는 클라이언트에 권한 부여 코드를 발급하는 대신 클라이언트에 액세스 토큰이 직접 발급된다(리소스 소유자 권한 부여의 결과).
허가 유형은 "암묵적"이다. 중간 자격 증명(예: 권한 부여 코드)이 발급되지 않는다(나중에 액세스 토큰을 얻는 데 사용됨).

암묵적 허가 흐름 중에 액세스 토큰을 발급할 때 인가 서버는 클라이언트를 인증하지 않는다. 
어떤 경우에는 클라이언트에 액세스 토큰을 전달하는 데 사용된 리디렉션 URI를 통해 클라이언트 ID를 확인할 수 있다. 
액세스 토큰은 자원 소유자나 자원 소유자의 `user-agent`에 접근 가능한 다른 애플리케이션들에 노출 될 수 있다.

암묵적 허가는 액세스 토큰을 얻는 데 필요한 왕복 횟수를 줄이기 때문에 일부 클라이언트(예: 브라우저 내 애플리케이션으로 구현된 클라이언트)의 응답성과 효율성을 개선한다. 
그러나 이러한 편의성은 특히 권한 부여 코드 허가 유형을 사용할 수 있는 경우 섹션 [10.3]() 및 [10.16]()에 설명된 것과 같은 암묵적 허가를 사용하는 것의 보안 의미와 비교해야 한다.

### 1.3.3. 자원 소유자 패스워드 자격증명::resource-owner-password-credentials

자원 소유자의 비밀번호 자격 증명(즉, 사용자 이름 및 비밀번호)은 액세스 토큰을 얻기 위한 권한 부여로 직접 사용할 수 있다. 
자격 증명은 자원 소유자와 클라이언트 간에 높은 신뢰 수준(예: 클라이언트가 장치 운영 체제 또는 권한이 높은 애플리케이션의 일부인 경우)이 있으면서,
다른 권한 부여 유형을 사용할 수 없는 경우(예: 권한 부여 코드)에만 사용해야 한다.

이 허가 유형은 클라이언트가 자원 소유자 자격 증명에 직접 액세스해야 하지만, 리소스 소유자 자격 증명은 단일 요청에 사용되고 액세스 토큰으로 교환된다.
이 허가 유형은 클라이언트가 자원 소유자 자격 증명을 나중에 사용하기 위해 저장할 필요성을 없앨 수 있으며, 자격 증명을 장기 액세스 토큰 또는 새로 고침 토큰과 교환합니다.

> 이 부분의 핵심은 자격증명(credentials)의 '일회성 사용'과 '교환' 개념에 있다.

### 1.3.4. 클라이언트 자격증명::client-credentials

클라이언트 자격 증명(또는 클라이언트 인증의 다른 형식)은 다음과 같은 경우에 권한 부여 방식으로 사용될 수 있다.

1. 권한 범위가 클라이언트가 직접 관리하는 보호된 자원에 한정될 때
2. 인가 서버와 사전에 협의된 보호된 자원일 때

클라이언트 자격 증명은 일반적으로 클라이언트가 자기 자신을 위해 행동(클라이언트가 자원 소유자 이기도 하다)하거나, 인가서버와 사전에 협의된 권한에 기반하여 보호된 자원에 접근을 요청할때 권한 부여로 사용된다.

## 1.4. 액세스 토큰::access-token

액세스 토큰은 보호된 자원 접근에 사용되는 자격증명이다. 액세스 토큰은 클라이언트에 발행되어 인가를 나타내는 문자열이다.
문자열은 보통 클라이언트가 이해하기 힘든 형식이다. 토큰은 인가서버와 자원서버로 부터 강제되며, 자원 소유자로부터 허가된 특정범위와 접근 기간을 나타낸다.

토큰은 검증 가능한 manner(예: 어떤 데이터와 서명으로 구성되는 토큰 문자열)에서 인가 정보나 자체 포함 일수도 있는 인가 정보를 가져오는데 사용되는 고유 값임을 나타낸다. 

토큰은 인가 정보를 검색하는데 사용하는 식별자나 검증 가능한 방식(즉, 어떤 데이터나 서명으로 구성되는 문자열)으로 인가 정보를 자체포함 할 수 있는것을 나타낼수 있다.
클라이언트가 토큰을 사용하기위해 추가적인 인증 자격증명이 필요할 수 있는데, 이는 명세서의 범위를 벗어난다.

액세스 토큰은 추상화 계층을 제공하는데, 자원 서버가 이해할 수 있는 단일 토큰으로 다른 인가 구성요소(예: 유저이름 및 비밀번호)를 대채한다.
이 추상화는 권한 부여보다 더 제한적인 기능으로서 액세스 토큰을 발행할 수 있으며, 자원서버가 다양한 인증수단을 이해하지 않아도 되도록 한다.

> 권한 부여보다 더 제한 적이라는 말은 부여 받을 수 있는 권한(읽기, 쓰기, 실행)보다 실제 액세스 토큰으로 수행할 수 있는 기능(읽기)으로 제한할 수 있다는 의이다.

엑세스 토큰은 자원 서버 보안 요구사항에 따른 서로다른 형식, 구조, 활용(예: 압호학적 속성) 방법을 가질 수 있다.
액세스 토큰의 속성과 보호된 자원에 접근하는 방법은 이 명세의 범위를 벗어나며, [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750)과 같은 관련 명세에 정의되어 있다.


## 1.5. 리프레시 토큰::refresh-token

리프레시 토큰은 액세스 토큰 획득에 사용되는 자격증명이다.
정리하자면, 리프레시 토큰은 인가 서버에서 클라이언트로 발행되며, 현재 액세스 토큰이 유효하지 않거나 만료 되었을 때, 또는 동일하거나 제한된 범위의 추가 액세스 토큰을 얻기 위해 사용된다.
(엑세스 토큰은 자원 소유자가 인가한 것 보다 더 더 짧은 수명과 더 적은 권한을 가질 수 있다) 
리프레시 토큰을 발급 받는 것은 인가서버의 재량으로 선택적이다. 인가 서버가 리프레시 토큰을 발급한다면, 이는 액세스 토큰(즉, 1번 그럼에서 (D) 단계)을 발급할 때 포함된다.

리프레시 토큰은 자원 소유자에 의해 클라이언트로 권한 부여를 나타내는 문자열이다. 문자열은 보톤 클라이언트가 알아볼 수 없는 형태이다. 
토큰은 인가 정보를 얻는데 사용되는 식별자를 나타낸다. 
액세스 토큰과 달리, 리프레시 토큰은 인가 서버에서만 사용만을 목적으로 하며 절대 자원 서버로 전송되지 않는다.

```
    +--------+                                           +---------------+
    |        |--(A)------- Authorization Grant --------->|               |
    |        |                                           |               |
    |        |<-(B)----------- Access Token -------------|               |
    |        |               & Refresh Token             |               |
    |        |                                           |               |
    |        |                            +----------+   |               |
    |        |--(C)---- Access Token ---->|          |   |               |
    |        |                            |          |   |               |
    |        |<-(D)- Protected Resource --| Resource |   | Authorization |
    | Client |                            |  Server  |   |     Server    |
    |        |--(E)---- Access Token ---->|          |   |               |
    |        |                            |          |   |               |
    |        |<-(F)- Invalid Token Error -|          |   |               |
    |        |                            +----------+   |               |
    |        |                                           |               |
    |        |--(G)----------- Refresh Token ----------->|               |
    |        |                                           |               |
    |        |<-(H)----------- Access Token -------------|               |
    +--------+           & Optional Refresh Token        +---------------+
```

만료된 액세스 토큰이 대한 리프레시는 아래와 같이 이루어진다:

* (A): 클라이언트는 인가 서버와 인증하고 권한 부여를 제시하여 액세스 토큰을 요청한다.
* (B): 인가서버는 클라이언트를 인증하고, 권한부여를 검증하며 유효하다면 액세스 토큰과 리프레시 토큰을 발행한다.
* (C): 클라이언트는 액세스 토큰을 제출하며 자원 서버로 보호된 자원을 요청한다.
* (D): 자원서버는 액세스 토큰을 검증하고, 유효하다면 요청을 처리한다.
* (E): (C), (D) 단계는 액세스 토큰이 만료될 때까지 반복된다. 만약 클라이언트에서 액세스 토큰이 만료된걸 알고 있다면 , (G) 단계로 스킵하며 그게 아니라면 보호된 자원을 요청한다.
* (F): 액세스 토큰이 유효하지 않으므로, 자원 서버는 invalid token error를 반환 한다.
* (G): 클라이언트는 인가 서버와 인증하고 리프레시 토큰을 전달하여 새로운 액세스 토큰을 요청한다. 클라이언트의 인증 요구사항은 클라이언트 유형과 인가 서버 정책을 따른다.
* (H): 인가 서버는 클라이언트를 인증하고 리프레시 토큰을 검증하며 유효하다면 새로운 액세스 토큰(선택적으로 새로운 리프레시 토큰도 발급)을 발행한다.

(C), (D), (E) 와 (F) 단계는 이 명세의 범위를 넘어서며, [섹션 7](https://datatracker.ietf.org/doc/html/rfc6749#section-7)에 서술되어있다.

## 1.6. TLS 버전::tls-version

이 사양(OAuth2.0)에서는 TLS(Transport Layer Security)를 사용하려는 경우에 알려진 보안 취약점과 배포되어 널리 사용중인 버전에 따라 시간이 흐르면서 적절한 TLS 버전이 변경될 수 있다.
이 문서의 작성 시점에는 TLS 1.2 버전 [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)이 가장 최신 버전이지만 많이 제한된 배포 기반을 가지며, 쉽게 구현이 어려울 수 도있다.
TLS 1.0 버전[RFC 2246](https://datatracker.ietf.org/doc/html/rfc2246)은 가장 널리 사용중이며, 가장 폭 넓은 상호 운영성을 제공한다.

구현체는 자신들의 보안 요구 사항을 충족하는 추가적인 전송 계층 보안 메커니즘을 지원할 수 있다.

## 1.7. HTTP 리다이렉션::http-redirections

이 명세는 HTTP 리다이렉션을 광범위하게 사용하는데, 여기서는 클라이언트나 인가서버에서 자원 소유자의 User-Agent를 다른 목적지로 안내한다.
이 명세의 예제들은 HTTP 302를 사용했지만, 리다이렉션을 수행하기 위해 user-agent가 사용할 수있는 다른 어떤 방법도 허용되며, 이는 구현 세부 사항으로 간주된다.

## 1.8. 상호 운용성::interoperability

OAuth 2.0은 보안 속성들이 명확하게 정의된 풍부한 기능의 인가 프레임워크이다. 

However, as a rich and highly extensible framework with many optional components, 
그러나, 많은 선택적 구성요소를 가지는 풍부하고 고확장성 프레임워크이며,

on its own, this specification is likely to produce a wide range of non-interoperable implementations.
프레임워크 자체에서 이 사양은 비운용적인 구현체의 넒은 범위를 생산할 가능성이 있다.



